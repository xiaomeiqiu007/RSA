# RSA小结

## 1.前言：
最近课上听了RSA觉得很有收获记录下。想通过这次学习更清楚相关数理知识更好的明白RSA！！！
## 2.RSA加密解密：
### 2.1.RSA加密过程

** (1).取两个互质的大素数q,p,n=q*p。**

** (2).利用欧拉函数算出fn=(q-1)*(p-1)(其中n是从1到q乘p素数的个数) **

** (3).从(1,fn)之间选取一个e，且e与n互质 **

** (4).计算e对于n的模反元素d（ed - 1 = kfn） **

** (5).进行加密函数的计算 m(e) ≡ c (mod n) **

### 2.2.RSA加密实例
** 取m=30进行加密传输 **

** (1).p=3，q=11，n=33 **

** (2).fn=20 **

** (3).e=3,3与20互质 **

** (4).d=7时，e×d≡1 mod f(n) **

** (5).计算m(3)mod(33)=6将6传输出去 **

** (6).进行解密测试， m(7)mod(33)=30，测试结果正确 **
## 3.RSA常见的攻击方式
### 3.1当n的值比较小能够被分解时，当n能够直接被分解为qp时这个时候就非常危险，
 例题：已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的公钥：
(N=322831561921859 e = 23)

这里可以直接利用http://www.factordb.com/index.php?query=322831561921859 。进行在线分解，分解出来p=23781539，q=13574881。利用python脚本进行加密解密。
```
# coding = utf-8
import libnum
def fastExpMod(b, e, m):
    """
    e = e0*(2^0) + e1*(2^1) + e2*(2^2) + ... + en * (2^n)

    b^e = b^(e0*(2^0) + e1*(2^1) + e2*(2^2) + ... + en * (2^n))
        = b^(e0*(2^0)) * b^(e1*(2^1)) * b^(e2*(2^2)) * ... * b^(en*(2^n))

    b^e mod m = ((b^(e0*(2^0)) mod m) * (b^(e1*(2^1)) mod m) * (b^(e2*(2^2)) mod m) * ... * (b^(en*(2^n)) mod m) mod m
    """
    result = 1
    while e != 0:
        if (e&1) == 1:
            # ei = 1, then mul
            result = (result * b) % m
        e >>= 1
        # b, b^2, b^4, b^8, ... , b^(2^n)
        b = (b*b) % m
    return result


def decryption(C, d, n):
    #RSA M = C^d mod n
    return fastExpMod(C, d, n)

p =
q =
n = p * q
fn = (p - 1) * (q - 1)
e = 23
d = libnum.invmod(e,fn)
print (d)
C = int('', 16)
M = decryption(C, d, n)
flag = str(hex(M))[2:-1]
print (flag)
```
### 3.2.低指数攻击
当e的值过于小，导致m的e次方小于n，那么根据公式m[e]=Cmod(n),这里m的e次方就先这样写了。根据公式我们可以直接推算出m=C的根号e次方。若m的e次方大于n，但是还不是特别的大，那么m=kn+C的根号n次方。如果能够直接被开出来那么我们也能直接也能求出来明文。
```
C=5456662369245103400102.........
N=0xB0BEE5E3E9E5A7E8D00B........
E=3
```
利用python脚本进行逐个爆破结果
```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__author__ = 'ByStudent'
from libnum import s2n,n2s
from gmpy2 import iroot
n = 0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929
e = 3
c = 545666236924510340010249577709750283325731706774285241719627277546281629429734726717293022303311450772262647904537263500252284243393598944613964442974546950954108203106726282255676706429218187217515454665602130999856741523362906632677988245886500953095201122016935004088287862399317170828388632964668574391252399791901016522260191839164586088073933168096433230663402492577707149742261018318811473591856287943664733276898405984282679026758294364432874973387827086342720762945025346962005339728347282927842299962927871005260338747371451546554777112213044710533502191671159066680035742327279159127279685106716107705888068319962657817786581813767331740609788885735155741039564703781141646102609725965697004923161084032164730408824475517786576979990372940555488021025837456038491436690372760376483602299268887032528766383572923258228355911069631275397149328319966792315903921085816103476508992023873616148326626245855060470294978538631677232260545724075728912626994884533001056079733734460116442499311813113038763837974777469202302071221647473459505245546281400799833123812072606012604323510933244028733287443734697557314202167934768160824072400916728008549350662843995750077421616789178835625661267955774815287104291379928002318796086248
i = 118719487
while 1:
    res = iroot(c+i*n,3)
    if(res[1] == True):
        print res
        break
    print "i="+str(i)
    i = i+1
#i=118719487
#（m的值为解出来的m）m = 440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186
#（n2s hex 转字符）print n2s(m)
# 结果
```
### 3.3.公约数求解pq。
整数唯一分解定理:每个整数可唯一地分解为素数的乘积。也就是说n只有可能被一组pq求解，假如题目给多个n，且每个n的位数都是2048级别的。正常情况之下无法真正的分解。但是如果这几个n之间能够求出公约数。根据整数唯一分解定理。我们可以求出qp。
例题：
```
n1 = 13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743
n2 = 9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327
```
利用python脚本尝试求解公约数。
```
n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743
n1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327
def gcd(a, b):
   if a < b:
     a, b = b, a
   while b != 0:
     temp = a % b
     a = b
     b = temp
   return a
print gcd(n1,n2)
```
